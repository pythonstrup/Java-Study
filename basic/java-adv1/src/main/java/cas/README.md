# 원자적 연산

- 컴퓨터 과학에서 사용하는 `원자적 연산 atomic operation`의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.
- 즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다.
  - 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻.

## 예시

- 다음 연산은 원자적 연산이다.

```java
i = 1;
```

- 이 연산은 단 하나의 순서로 실행된다.

1. 오른쪽에 있는 1의 값을 왼쪽 `i` 변수에 대입

- 반면 다음 연산은 원자적 연산이 아니다.

```java
i = i + 1;
```

- 왜냐하면 이 연산은 아래와 같은 순서로 나눠서 실행되기 때문이다.

1. 오른쪽에 있는 `i`의 값을 읽는다. `i`의 값은 10이다.
2. 읽은 10에 1을 더해서 11을 만든다.
3. 11을 왼쪽 `i` 변수에 대입

- 원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다. 하지만 원자적 연산이 아니라면 `synchronized` 블록이나 `Lock` 등을 사용해서 안전한 임계 영역을 만들어야 한다.

---

<br>

# CAS 연산

## 락 기반 방식의 문제점

- 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근을 제한한다.
- 락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.
  - 또한 락을 획득하고 해제하는 데 시간이 소요된다.

## CAS

- 이런 문제를 해결하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법이 있는데, 이를 CAS(Compare-And-Swap, Compare-And-Set) 연산이라 한다.
- 이 방법은 락을 사용하지 않기 때문에 `락 프리 lock-free` 기법이라 한다.
- 락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 적용할 수 있다.
  - 기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있다고 생각하면 된다.

### compareAndSet()

- Atomic 타입은 `compareAndSet()`이라는 메소드를 통해 CAS 연산을 지원한다.
- 이 메소드를 사용해 원자적이지 않은 연산을 원자적으로 실행할 수 있다.

```java
AtomicInteger atomicInteger = new AtomicInteger(0);
atomicInteger.compareAndSet(0, 1);
```

### CPU 하드웨어의 지원

- CAS 연산은 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.
- 소프트웨어 X. 하드웨어가 제공하는 기능이다!
  - 대부분의 현대 CPU들은 CAS 연산을 위한 명령어를 제공한다.
- CPU는 다음 두 과정을 묶어서 하나의 원자적인 명령으로 만들어버린다. 따라서 중간에 다른 스레드가 개입할 수 없다.
1. x001의 값을 확인한다.
2. 읽은 값이 0이면 1로 변경한다.

### CAS 정리

1. 기대하는 값을 확인하고
2. 값을 변경하는 두 연산을 하나로 묶어서 원자적으로 제공.

- 이 기능이 어떻게 락의 일부를 대체한다는 걸까?

### incrementAndGet()

- 아래는 직접 만들어본 코드

```java
private static int incrementAndGet(final AtomicInteger atomicInteger) {
  int getValue;
  boolean result;
  do {
    getValue = atomicInteger.get();
    log("getValue: " + getValue);
    result = atomicInteger.compareAndSet(getValue, getValue + 1);
    log("result: " + result);
  } while (!result);
  return getValue + 1;
}
```

- `incrementAndGet()` 코드는 CAS를 활용하도록 작성되어 있다.
- CAS는 락을 사용하지 않지만, 대신에 다른 스레드가 값을 먼저 증가해서 문제가 발생하는 경우 루프를 돌며 재시도하는 방식을 사용

1. 현재 변수의 값을 읽어온다.
2. 변수의 값을 1 증가시킨다.
3. 증가시킨 값을 원래 변수와 비교하여 동일한지 확인한다. (CAS 연산 사용)
4. 동일하다면 증가된 값을 변수에 저장하고 종료
5. 동일하지 않다면 다른 스레드가 값을 변경한 것이므로, 다시 처음으로 돌아가 위 과정을 반복.

- 두 스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현한다.
  - 이 과정에서 충돌이 발생할 때마다 반복해서 다시 시도하므로, 결과적으로 락 없이 데이터를 안전하게 변경할 수 없다.
  - 충돌이 드물게 발생하는 환경에서는 락을 사용하지 않으므로 높은 성능을 발휘할 수 있다.
  - 스레드가 락을 획득하기 위해 대기하지 않기 때문에 대기 시간과 오버헤드가 줄어드는 장점이 있다.
- 그러나 충돌이 빈번하게 발생하는 환경에서는 성능에 문제가 될 수 있다.
  - 반복문을 계속 돌기 때문에 CPU 자원을 많이 소모하게 된다.

### CAS과 Lock 방식의 비교

#### Lock

- 비관적 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막음
- "다른 스레드가 방해할 것이다"라고 가정

#### CAS

- 낙관적 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"라고 가정

#### 정리

- CPU 연산에는 락보다는 CAS를 사용하는 것이 효과적이다.
