# 생산자 소비자 문제

- `생산자 Producer`: 데이터를 생성하는 역할을 한다.
  - ex) 파일에서 데이터 읽어오기, 네트워크에서 데이터 받아오기.
- `소비자 Consumer`: 생성된 데이터를 사용하는 역할
  - ex) 데이터를 처리하거나 저장하는 스레드가 소비자 역할
- `버퍼 Buffer`: 생산자가 생성한 데이터를 일시적으로 저장하는 공간. 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고 받는다.
  - ex) 프린터 예제에서의 프린터 큐

## 문제 상황

- 생산자가 너무 빠를 때: 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다. 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.
- 소비자가 너무 빠를 때: 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다. 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.

## 용어

아래 두 용어는 같은 의미다.

- `생산자 소비자 문제 producer-consumer problem`: 생산자 소비자 문제는, 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제다.
- `한정된 버퍼 문제 bounded-buffer problem`: 이 문제는 결국 버퍼의 크기가 한정되어 있기 때문에 발생한다. 따라서 한정된 버퍼 문제라고도 한다.

## 단순하게 해결해보기?

- 소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다.
  - 물론 생산자가 데이터를 계속 생산한다는 가정이 필요하다.
- 단순하게 생각하면 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한 다음, 만약 데이터가 없다면 `sleep()`을 짧게 사용해 잠시 대기하고 깨어나 다시 반복문에서 데이터가 있는지 확인하는 식으로 구현도 가능할 것이다.

### 하지만 여기서 무한 대기 문제가 발생한다.

- `synchronized` 키워드를 메소드 레벨에서 사용할 경우 `this`를 사용하여 Lock을 건다.
- 임계 영역의 Lock을 획득한 상태에서 생산자 스레드가 대기하고 있다면, 소비자가 소비를 하고 싶어도 Lock이 걸려 있어 접근할 수가 없다.
  - 무한 대기를 하게 된다는 의미다.

```
15:24:46.268 [     main] 현재 상태 출력, 큐 데이터: [data1, data2]
15:24:46.269 [     main] producer1: TERMINATED
15:24:46.269 [     main] producer2: TERMINATED
15:24:46.269 [     main] producer3: TIMED_WAITING
15:24:46.270 [     main] consumer1: BLOCKED
15:24:46.270 [     main] consumer2: BLOCKED
15:24:46.270 [     main] consumer3: BLOCKED
15:24:46.852 [producer3] [put] 큐가 가득 참, 생산자 대기
15:24:47.857 [producer3] [put] 큐가 가득 참, 생산자 대기
15:24:48.862 [producer3] [put] 큐가 가득 참, 생산자 대기
...
```

## `Object` - `wait()`, `notify()`

- "락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다면! 해결할 수 있다."
- 자바의 `Object.wait()`, `Object.notify()`를 사용하면 락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다.

### 설명

- `Object.wait()`
  - 현재 스레드가 가진 락을 반납하고 `대기 WAITING`한다.
  - 현재 스레드를 `대기 WAITING` 상태로 전환한다. 이 메소드는 현재 스레드가 `synchronized` 블록이나 메소드에서 락을 소유하고 있을 때만 호출할 수 있다.
  - 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다. 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()`을 호출할 때까지 대기 상태를 유지한다.
- `Obejct.notify()`
  - 대기 중인 스레드 중 하나를 깨운다.
  - 이 메소드는 `synchronized` 블록이나 메소드에서 호출되어야 한다.
  - 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다. 만약 대기 중인 스레드가 여러 개라면, 그 중 하나만 깨워지게 된다.
- `Object.notifyAll()`
  - 대기 중인 모든 스레드를 깨운다.
  - 이 메소드 역시 `synchronized` 블록이나 메소드에서 호출되어야 하며, 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다. 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.

### 한계

- 스레드 대기 집합 하나에 생산자, 소비자 스레드를 모두 관라한다.
  - 즉, `notify()`를 호출할 때 임의의 스레드가 선택된다. 
  - 따라서 큐에 데이터가 없는 상황에도 소비자를 깨우는 비효율이 발생할 수 있다.
  - 혹은 큐가 가득 찼는데 생산자를 깨우는 비효율도 발생할 수 있다.

#### 스레드 기아 thread starvation

- `notify()`가 어떤 스레드를 깨울지는 알 수 없다. 최악의 경우, 소비자만 반복해서 깨우는 비효율이 발생할 수 있다.
- 이렇게 대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황을 기아 상태라 한다.
  - 이 문제를 해결하기 위해 `notifyAll()` 사용해볼 수 있다.
- `notifyAll()`을 호출하면 모든 스레드가 Lock 획득 시도를 한다.
  - 아쉽게도 `notifyAll()`도 비효율이 발생한다는 문제가 있다.
- 너무 걱정 ㄴㄴ -> Java에서 내부적으로 웬만하면 오래 기다렸던 스레드가 실행되도록 한다고 함.  
